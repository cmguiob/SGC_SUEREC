data = agg_ph,
lower = agg_ph$p.q25,
upper = agg_ph$p.q75,
ylim = c(max(agg_ph$top), 0),
ylab = "Profundidad (cm)",
xlab = "Mediana y percentiles 25–75 de pH",
panel = panel.depth_function,
prepanel = prepanel.depth_function,
alpha = 0.3,
sync.colors = TRUE,
cf = agg_ph$contributing_fraction,
cf.col = 'black',
cf.interval = 20,
cf.cex = 0.5,  # << tamaño reducido del % de contribución
layout = c(1, 1),
par.settings = list(
superpose.line = list(col = 'slateblue', lwd = 2),
axis.text = list(cex = 0.65),
par.xlab.text = list(cex = 0.8),
par.ylab.text = list(cex = 0.8),
strip.background = list(col = grey(0.9))
),
strip = strip.custom(bg = grey(0.9), style = 1),  # asegurar que se dibuje
par.strip.text=list(cex=0.8),
scales = list(
x = list(relation = 'same', alternating = 3, cex = 0.65),
y = list(cex = 0.65)
)
)
dev.off()
# Calcular estadísticos de pH por profundidad (1 cm)
agg_ph <- slab(datos_spc, fm = ~ ph_lab)
# Exportar gráfico angosto con texto reducido
png("curva_tipo_ph.png", width = 3.2, height = 4, units = "in", res = 300)
xyplot(
top ~ p.q50 | variable,
data = agg_ph,
lower = agg_ph$p.q25,
upper = agg_ph$p.q75,
ylim = c(max(agg_ph$top), 0),
ylab = "Profundidad (cm)",
xlab = "Mediana y percentiles 25–75 de pH",
panel = panel.depth_function,
prepanel = prepanel.depth_function,
alpha = 0.3,
sync.colors = TRUE,
cf = agg_ph$contributing_fraction,
cf.col = 'black',
cf.interval = 20,
cf.cex = 0.5,  # << tamaño reducido del % de contribución
layout = c(1, 1),
par.settings = list(
superpose.line = list(col = 'slateblue', lwd = 2),
axis.text = list(cex = 1),
par.xlab.text = list(cex = 1.2),
par.ylab.text = list(cex = 1.2),
strip.background = list(col = grey(0.9))
),
strip = strip.custom(bg = grey(1.2), style = 1),  # asegurar que se dibuje
par.strip.text=list(cex=0.8),
scales = list(
x = list(relation = 'same', alternating = 3, cex = 0.65),
y = list(cex = 0.65)
)
)
# Calcular estadísticos de pH por profundidad (1 cm)
agg_ph <- slab(datos_spc, fm = ~ ph_lab)
# Exportar gráfico angosto con texto reducido
png("curva_tipo_ph.png", width = 3.2, height = 4, units = "in", res = 300)
xyplot(
top ~ p.q50 | variable,
data = agg_ph,
lower = agg_ph$p.q25,
upper = agg_ph$p.q75,
ylim = c(max(agg_ph$top), 0),
ylab = "Profundidad (cm)",
xlab = "Mediana y percentiles 25–75 de pH",
panel = panel.depth_function,
prepanel = prepanel.depth_function,
alpha = 0.3,
sync.colors = TRUE,
cf = agg_ph$contributing_fraction,
cf.col = 'black',
cf.interval = 20,
cf.cex = 0.5,  # << tamaño reducido del % de contribución
layout = c(1, 1),
par.settings = list(
superpose.line = list(col = 'slateblue', lwd = 2),
axis.text = list(cex = 1),
par.xlab.text = list(cex = 1.2),
par.ylab.text = list(cex = 1.2),
strip.background = list(col = grey(0.9))
),
strip = strip.custom(bg = grey(1.2), style = 1),  # asegurar que se dibuje
par.strip.text=list(cex=0.8),
scales = list(
x = list(relation = 'same', alternating = 3, cex = 0.65),
y = list(cex = 0.65)
)
)
# Calcular estadísticos de pH por profundidad (1 cm)
agg_ph <- slab(datos_spc, fm = ~ ph_lab)
# Exportar gráfico angosto con texto reducido
png("curva_tipo_ph.png", width = 3.2, height = 4, units = "in", res = 300)
xyplot(
top ~ p.q50 | variable,
data = agg_ph,
lower = agg_ph$p.q25,
upper = agg_ph$p.q75,
ylim = c(max(agg_ph$top), 0),
ylab = "Profundidad (cm)",
xlab = "Mediana y percentiles 25–75 de pH",
panel = panel.depth_function,
prepanel = prepanel.depth_function,
alpha = 0.3,
sync.colors = TRUE,
cf = agg_ph$contributing_fraction,
cf.col = 'black',
cf.interval = 20,
cf.cex = 0.5,  # << tamaño reducido del % de contribución
layout = c(1, 1),
par.settings = list(
superpose.line = list(col = 'slateblue', lwd = 2),
axis.text = list(cex = 0.9),
par.xlab.text = list(cex = 1.2),
par.ylab.text = list(cex = 1.2),
strip.background = list(col = grey(0.9))
),
strip = strip.custom(bg = grey(0.9), style = 1),  # asegurar que se dibuje
par.strip.text=list(cex=1.2),
scales = list(
x = list(relation = 'same', alternating = 3, cex = 0.65),
y = list(cex = 0.65)
)
)
dev.off()
# Calcular estadísticos de pH por profundidad (1 cm)
agg_ph <- slab(datos_spc, fm = ~ ph_lab)
# Exportar gráfico angosto con texto reducido
png("curva_tipo_ph.png", width = 3.2, height = 4, units = "in", res = 300)
xyplot(
top ~ p.q50 | variable,
data = agg_ph,
lower = agg_ph$p.q25,
upper = agg_ph$p.q75,
ylim = c(max(agg_ph$top), 0),
ylab = "Profundidad (cm)",
xlab = "Mediana y percentiles 25–75 de pH",
panel = panel.depth_function,
prepanel = prepanel.depth_function,
alpha = 0.3,
sync.colors = TRUE,
cf = agg_ph$contributing_fraction,
cf.col = 'black',
cf.interval = 20,
cf.cex = 0.5,  # << tamaño reducido del % de contribución
layout = c(1, 1),
par.settings = list(
superpose.line = list(col = 'slateblue', lwd = 2),
axis.text = list(cex = 0.9),
par.xlab.text = list(cex = 1.1),
par.ylab.text = list(cex = 1.1),
strip.background = list(col = grey(0.9))
),
strip = strip.custom(bg = grey(0.9), style = 1),  # asegurar que se dibuje
par.strip.text=list(cex=1.1),
scales = list(
x = list(relation = 'same', alternating = 3, cex = 0.65),
y = list(cex = 0.65)
)
)
dev.off()
# Calcular estadísticos de pH por profundidad (1 cm)
agg_ph <- slab(datos_spc, fm = ~ ph_lab)
# Exportar gráfico angosto con texto reducido
png("curva_tipo_ph.png", width = 3.2, height = 4, units = "in", res = 300)
xyplot(
top ~ p.q50 | variable,
data = agg_ph,
lower = agg_ph$p.q25,
upper = agg_ph$p.q75,
ylim = c(max(agg_ph$top), 0),
ylab = "Profundidad (cm)",
xlab = "Mediana y percentiles 25–75 de pH",
panel = panel.depth_function,
prepanel = prepanel.depth_function,
alpha = 0.3,
sync.colors = TRUE,
cf = agg_ph$contributing_fraction,
cf.col = 'black',
cf.interval = 20,
cf.cex = 0.5,  # << tamaño reducido del % de contribución
layout = c(1, 1),
par.settings = list(
superpose.line = list(col = 'slateblue', lwd = 2),
axis.text = list(cex = 0.8),
par.xlab.text = list(cex = 1),
par.ylab.text = list(cex = 1),
strip.background = list(col = grey(0.9))
),
strip = strip.custom(bg = grey(0.9), style = 1),  # asegurar que se dibuje
par.strip.text=list(cex=1),
scales = list(
x = list(relation = 'same', alternating = 3, cex = 0.65),
y = list(cex = 0.65)
)
)
dev.off()
# Calcular estadísticos de pH por profundidad (1 cm)
agg_ph <- slab(datos_spc, fm = ~ ph_lab)
# Exportar gráfico angosto con texto reducido
png("curva_tipo_ph.png", width = 3.2, height = 4, units = "in", res = 300)
xyplot(
top ~ p.q50 | variable,
data = agg_ph,
lower = agg_ph$p.q25,
upper = agg_ph$p.q75,
ylim = c(max(agg_ph$top), 0),
ylab = "Profundidad (cm)",
xlab = "Mediana y percentiles 25–75 de pH",
panel = panel.depth_function,
prepanel = prepanel.depth_function,
alpha = 0.3,
sync.colors = TRUE,
cf = agg_ph$contributing_fraction,
cf.col = 'black',
cf.interval = 20,
cf.cex = 0.5,  # << tamaño reducido del % de contribución
layout = c(1, 1),
par.settings = list(
superpose.line = list(col = 'slateblue', lwd = 2),
axis.text = list(cex = 0.8),
par.xlab.text = list(cex = 1),
par.ylab.text = list(cex = 1),
strip.background = list(col = grey(0.9))
),
strip = strip.custom(bg = grey(0.9), style = 1),  # asegurar que se dibuje
par.strip.text=list(cex=1),
scales = list(
x = list(relation = 'same', alternating = 3, cex = 1),
y = list(cex = 0.65)
)
)
dev.off()
# Calcular estadísticos de pH por profundidad (1 cm)
agg_ph <- slab(datos_spc, fm = ~ ph_lab)
# Exportar gráfico angosto con texto reducido
png("curva_tipo_ph.png", width = 3.2, height = 4, units = "in", res = 300)
xyplot(
top ~ p.q50 | variable,
data = agg_ph,
lower = agg_ph$p.q25,
upper = agg_ph$p.q75,
ylim = c(max(agg_ph$top), 0),
ylab = "Profundidad (cm)",
xlab = "Mediana y percentiles 25–75 de pH",
panel = panel.depth_function,
prepanel = prepanel.depth_function,
alpha = 0.3,
sync.colors = TRUE,
cf = agg_ph$contributing_fraction,
cf.col = 'black',
cf.interval = 20,
cf.cex = 0.5,  # << tamaño reducido del % de contribución
layout = c(1, 1),
par.settings = list(
superpose.line = list(col = 'slateblue', lwd = 2),
axis.text = list(cex = 0.8),
par.xlab.text = list(cex = 1),
par.ylab.text = list(cex = 1),
strip.background = list(col = grey(0.9))
),
strip = strip.custom(bg = grey(0.9), style = 1),  # asegurar que se dibuje
par.strip.text=list(cex=1),
scales = list(
x = list(relation = 'same', alternating = 3, cex = 0.8),
y = list(cex = 0.65)
)
)
dev.off()
# 1. Calcular pH ponderado por espesor de horizonte
wt.mean.ph <- function(i) {
thick <- i$bottom - i$top
wtd.mean(i$ph_lab, weights = thick, na.rm = TRUE)
}
site(datos_spc)$ph_weighted <- profileApply(datos_spc, wt.mean.ph)
# 2. Ordenar perfiles según el pH ponderado
orden_por_ph <- order(site(datos_spc)$ph_weighted)
# 3. Exportar PNG con layout dividido
png("perfil_tipo_ph.png", width = 6, height = 4, units = "in", res = 300)
# Definir layout: 93% perfiles (fila 1), 7% leyenda (fila 2)
layout(matrix(1:2, nrow = 2), heights = c(0.93, 0.07))
# ──────────────── PANEL 1: Gráfico de perfiles ────────────────
par(mar = c(5.2, 0, 4, 2))  # márgenes para que no corte etiquetas ni el eje
plotSPC(
datos_spc,
plot.order = orden_por_ph,
color = "color_hz",
cex.names = 0.4,
depth.axis = list(style = "traditional", cex = 0.6),
width = 0.4,
name.style = "center-center",
hz.distinctness.offset = "hd",
hz.topography.offset = "hzto",
hz.boundary.lty = "hzto.lty"
)
# Eje inferior con etiquetas de pH ponderado
axis(
1,
at = 1:length(datos_spc),
labels = round(site(datos_spc)$ph_weighted[orden_por_ph], 2),
cex.axis = 0.6,
las = 2
)
# Etiqueta del eje x
mtext(
side = 1,
line = 3.8,
text = "pH ponderado por espesor de horizonte",
cex = 0.8
)
# ──────────────── PANEL 2: Leyenda ────────────────
par(mar = c(0, 0, 0, 0))
plot.new()
legend(
"center",
horiz = TRUE,
legend = c("Smooth", "Wavy", "Irregular", "Broken"),
lty = 1:4,
bty = "n",
cex = 0.8
)
dev.off()
# Calcular estadísticos de pH por profundidad (1 cm)
agg_ph <- slab(datos_spc, fm = ~ ph_lab)
# Exportar gráfico angosto con texto reducido
png("curva_tipo_ph.png", width = 3.2, height = 4, units = "in", res = 300)
xyplot(
top ~ p.q50 | variable,
data = agg_ph,
lower = agg_ph$p.q25,
upper = agg_ph$p.q75,
ylim = c(max(agg_ph$top), 0),
ylab = "Depth (cm)",
xlab = "Mean pH and IQR",
panel = panel.depth_function,
prepanel = prepanel.depth_function,
alpha = 0.3,
sync.colors = TRUE,
cf = agg_ph$contributing_fraction,
cf.col = 'black',
cf.interval = 20,
cf.cex = 0.5,  # << tamaño reducido del % de contribución
layout = c(1, 1),
par.settings = list(
superpose.line = list(col = 'slateblue', lwd = 2),
axis.text = list(cex = 0.8),
par.xlab.text = list(cex = 1),
par.ylab.text = list(cex = 1),
strip.background = list(col = grey(0.9))
),
strip = strip.custom(bg = grey(0.9), style = 1),  # asegurar que se dibuje
par.strip.text=list(cex=1),
scales = list(
x = list(relation = 'same', alternating = 3, cex = 0.8),
y = list(cex = 0.65)
)
)
dev.off()
# 1. Calcular pH ponderado por espesor de horizonte
wt.mean.ph <- function(i) {
thick <- i$bottom - i$top
wtd.mean(i$ph_lab, weights = thick, na.rm = TRUE)
}
site(datos_spc)$ph_weighted <- profileApply(datos_spc, wt.mean.ph)
# 2. Ordenar perfiles según el pH ponderado
orden_por_ph <- order(site(datos_spc)$ph_weighted)
# 3. Exportar PNG con layout dividido
png("perfil_tipo_ph.png", width = 6, height = 4, units = "in", res = 300)
# Definir layout: 93% perfiles (fila 1), 7% leyenda (fila 2)
layout(matrix(1:2, nrow = 2), heights = c(0.93, 0.07))
# ──────────────── PANEL 1: Gráfico de perfiles ────────────────
par(mar = c(5.2, 0, 4, 2))  # márgenes para que no corte etiquetas ni el eje
plotSPC(
datos_spc,
plot.order = orden_por_ph,
color = "color_hz",
cex.names = 0.4,
depth.axis = list(style = "traditional", cex = 0.6),
width = 0.4,
name.style = "center-center",
hz.distinctness.offset = "hd",
hz.topography.offset = "hzto",
hz.boundary.lty = "hzto.lty"
)
# Eje inferior con etiquetas de pH ponderado
axis(
1,
at = 1:length(datos_spc),
labels = round(site(datos_spc)$ph_weighted[orden_por_ph], 2),
cex.axis = 0.6,
las = 2
)
# Etiqueta del eje x
mtext(
side = 1,
line = 3.8,
text = "Mean pH weghted by horizon thickness",
cex = 0.8
)
# ──────────────── PANEL 2: Leyenda ────────────────
par(mar = c(0, 0, 0, 0))
plot.new()
legend(
"center",
horiz = TRUE,
legend = c("Smooth", "Wavy", "Irregular", "Broken"),
lty = 1:4,
bty = "n",
cex = 0.8
)
dev.off()
# Calcular estadísticos de pH por profundidad (1 cm)
agg_ph <- slab(datos_spc, fm = ~ ph_lab)
# Exportar gráfico angosto con texto reducido
png("curva_tipo_ph.png", width = 3.2, height = 4, units = "in", res = 300)
xyplot(
top ~ p.q50 | variable,
data = agg_ph,
lower = agg_ph$p.q25,
upper = agg_ph$p.q75,
ylim = c(max(agg_ph$top), 0),
ylab = "Depth (cm)",
xlab = "Mean pH and IQR",
panel = panel.depth_function,
prepanel = prepanel.depth_function,
alpha = 0.3,
sync.colors = TRUE,
cf = agg_ph$contributing_fraction,
cf.col = 'black',
cf.interval = 20,
cf.cex = 0.5,  # << tamaño reducido del % de contribución
layout = c(1, 1),
par.settings = list(
superpose.line = list(col = 'slateblue', lwd = 2),
axis.text = list(cex = 0.8),
par.xlab.text = list(cex = 1),
par.ylab.text = list(cex = 1),
strip.background = list(col = grey(0.9))
),
strip = strip.custom(bg = grey(0.9), style = 1),  # asegurar que se dibuje
par.strip.text=list(cex=1),
scales = list(
x = list(relation = 'same', alternating = 3, cex = 0.8),
y = list(cex = 0.65)
)
)
dev.off()
# 1. Calcular pH ponderado por espesor de horizonte
wt.mean.ph <- function(i) {
thick <- i$bottom - i$top
wtd.mean(i$ph_lab, weights = thick, na.rm = TRUE)
}
site(datos_spc)$ph_weighted <- profileApply(datos_spc, wt.mean.ph)
# 2. Ordenar perfiles según el pH ponderado
orden_por_ph <- order(site(datos_spc)$ph_weighted)
# 3. Exportar PNG con layout dividido
png("perfil_tipo_ph.png", width = 6, height = 4, units = "in", res = 300)
# Definir layout: 93% perfiles (fila 1), 7% leyenda (fila 2)
layout(matrix(1:2, nrow = 2), heights = c(0.93, 0.07))
# ──────────────── PANEL 1: Gráfico de perfiles ────────────────
par(mar = c(5.2, 0, 4, 2))  # márgenes para que no corte etiquetas ni el eje
plotSPC(
datos_spc,
plot.order = orden_por_ph,
color = "color_hz",
cex.names = 0.4,
depth.axis = list(style = "traditional", cex = 0.6),
width = 0.4,
name.style = "center-center",
hz.distinctness.offset = "hd",
hz.topography.offset = "hzto",
hz.boundary.lty = "hzto.lty"
)
# Eje inferior con etiquetas de pH ponderado
axis(
1,
at = 1:length(datos_spc),
labels = round(site(datos_spc)$ph_weighted[orden_por_ph], 2),
cex.axis = 0.6,
las = 2
)
# Etiqueta del eje x
mtext(
side = 1,
line = 3.8,
text = "Mean pH weighted by horizon thickness",
cex = 0.8
)
# ──────────────── PANEL 2: Leyenda ────────────────
par(mar = c(0, 0, 0, 0))
plot.new()
legend(
"center",
horiz = TRUE,
legend = c("Smooth", "Wavy", "Irregular", "Broken"),
lty = 1:4,
bty = "n",
cex = 0.8
)
dev.off()
slab
